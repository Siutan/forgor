package cmd

import (
	"bufio"
	"fmt"
	"forgor/internal/config"
	"forgor/internal/llm"
	"forgor/internal/security"
	"forgor/internal/utils"
	"os"
	"strings"

	"github.com/spf13/cobra"
)

var (
	runForce bool
	runQuiet bool
)

// runCmd represents the run command
var runCmd = &cobra.Command{
	Use:   "run [command]",
	Short: "Execute a shell command with safety checks",
	Long: `Execute a shell command with built-in safety checks and confirmation prompts.

This command provides a safe way to execute commands generated by forgor or any other shell command.
It includes dangerous command detection and confirmation prompts.

If no command is provided, it will execute the last command generated by forgor.

Examples:
  forgor run                             # Execute the last generated command
  forgor run "ls -la"                    # Execute specific command with confirmation  
  forgor run -F "rm temp.txt"            # Force execute without confirmation
  forgor run -q "echo hello"             # Quiet mode (less output)`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		var command string
		var err error

		if len(args) == 0 {
			// No command provided, use the last generated command
			command, err = config.LoadLastCommand()
			if err != nil {
				return err
			}

			if !runQuiet {
				fmt.Printf("📋 Using last generated command: %s\n", command)
			}
		} else {
			// Command provided as argument
			command = args[0]
		}

		if runQuiet {
			// In quiet mode, suppress some output
			oldVerbose := verbose
			verbose = false
			defer func() { verbose = oldVerbose }()
		}

		if runForce {
			// Force execution - set the global forceRun flag temporarily
			oldForceRun := forceRun
			forceRun = true
			defer func() { forceRun = oldForceRun }()
		}

		if verbose && !runQuiet {
			fmt.Printf("🔍 Executing command: %s\n", command)
		}

		// Use enhanced danger assessment
		return executeCommandEnhanced(command)
	},
}

// executeCommandEnhanced runs a command with sophisticated danger assessment
func executeCommandEnhanced(command string) error {
	if command == "" {
		return fmt.Errorf("no command to execute")
	}

	// Create danger detector and assess the command
	detector := security.NewDangerDetector()
	ctx := &llm.Context{
		OS:               utils.GetOperatingSystem(),
		Shell:            utils.GetCurrentShell(),
		WorkingDirectory: utils.GetWorkingDirectory(),
	}
	assessment := detector.AssessCommand(command, ctx)

	// Show danger assessment
	if assessment.Level != llm.DangerLevelSafe {
		icon := getDangerIcon(assessment.Level)
		fmt.Printf("%s %s DANGER LEVEL: %s\n", icon,
			strings.ToUpper(string(assessment.Level)), assessment.Reason)

		if len(assessment.Factors) > 0 {
			fmt.Printf("⚠️  Risk factors:\n")
			for _, factor := range assessment.Factors {
				fmt.Printf("  • %s\n", factor)
			}
		}

		if len(assessment.Mitigations) > 0 {
			fmt.Printf("💡 Safety recommendations:\n")
			for _, mitigation := range assessment.Mitigations {
				fmt.Printf("  • %s\n", mitigation)
			}
		}
		fmt.Println()
	}

	// Enhanced safety checks based on danger level
	if assessment.Level >= llm.DangerLevelMedium && !runForce {
		if err := handleDangerousExecution(command, assessment); err != nil {
			return err
		}
	} else if !runForce {
		// For low/safe commands, still ask for confirmation unless forced
		if !runQuiet {
			fmt.Printf("Execute: %s\n", command)
			fmt.Printf("Continue? [Y/n]: ")

			reader := bufio.NewReader(os.Stdin)
			response, err := reader.ReadString('\n')
			if err != nil {
				return fmt.Errorf("failed to read confirmation: %w", err)
			}

			response = strings.TrimSpace(strings.ToLower(response))
			if response != "" && response != "y" && response != "yes" {
				fmt.Printf("❌ Command execution cancelled\n")
				return nil
			}
		}
	}

	// Execute the command using the standard execution logic
	return executeCommand(command, assessment.Factors)
}

// handleDangerousExecution handles execution confirmation for dangerous commands
func handleDangerousExecution(command string, assessment llm.DangerAssessment) error {
	icon := getDangerIcon(assessment.Level)
	fmt.Printf("%s %s COMMAND DETECTED!\n", icon, strings.ToUpper(string(assessment.Level)))
	fmt.Printf("Command: %s\n", command)
	fmt.Printf("Reason: %s\n\n", assessment.Reason)

	if assessment.Level >= llm.DangerLevelHigh {
		fmt.Printf("This command may be destructive. Type 'YES I UNDERSTAND THE RISKS' to confirm: ")

		reader := bufio.NewReader(os.Stdin)
		response, err := reader.ReadString('\n')
		if err != nil {
			return fmt.Errorf("failed to read confirmation: %w", err)
		}

		if strings.TrimSpace(response) != "YES I UNDERSTAND THE RISKS" {
			fmt.Printf("❌ Command execution cancelled\n")
			return nil
		}
	} else {
		fmt.Printf("Continue? (type 'yes' to confirm): ")

		reader := bufio.NewReader(os.Stdin)
		response, err := reader.ReadString('\n')
		if err != nil {
			return fmt.Errorf("failed to read confirmation: %w", err)
		}

		if strings.TrimSpace(strings.ToLower(response)) != "yes" {
			fmt.Printf("❌ Command execution cancelled\n")
			return nil
		}
	}

	return nil
}

// getDangerIcon returns an appropriate icon for the danger level
func getDangerIcon(level llm.DangerLevel) string {
	switch level {
	case llm.DangerLevelSafe:
		return "✅"
	case llm.DangerLevelLow:
		return "🟡"
	case llm.DangerLevelMedium:
		return "🟠"
	case llm.DangerLevelHigh:
		return "🔴"
	case llm.DangerLevelCritical:
		return "💀"
	default:
		return "❓"
	}
}

func init() {
	rootCmd.AddCommand(runCmd)

	// Add flags for the run command
	runCmd.Flags().BoolVarP(&runForce, "force", "F", false, "force execute without confirmation (DANGEROUS)")
	runCmd.Flags().BoolVarP(&runQuiet, "quiet", "q", false, "quiet mode - less output")
}
