package cmd

import (
	"bufio"
	"errors"
	"fmt"
	"forgor/internal/config"
	"forgor/internal/llm"
	"forgor/internal/security"
	"forgor/internal/utils"
	"os"
	"os/exec"
	"strings"

	"github.com/spf13/cobra"
)

var (
	runForce bool
	runQuiet bool

	// ErrCommandCancelled indicates the user cancelled command execution
	ErrCommandCancelled = errors.New("command execution cancelled by user")
)

// runCmd represents the run command
var runCmd = &cobra.Command{
	Use:   "run [command]",
	Short: "Execute a shell command with safety checks",
	Long: `Execute a shell command with built-in safety checks and confirmation prompts.

This command provides a safe way to execute commands generated by forgor or any other shell command.
It includes dangerous command detection and confirmation prompts.

If no command is provided, it will execute the last command generated by forgor.

Examples:
  forgor run                             # Execute the last generated command
  forgor run "ls -la"                    # Execute specific command with confirmation  
  forgor run -F "rm temp.txt"            # Force execute without confirmation
  forgor run -q "echo hello"             # Quiet mode (less output)`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		var command string
		var err error

		if len(args) == 0 {
			// No command provided, use the last generated command
			command, err = config.LoadLastCommand()
			if err != nil {
				return err
			}

			if !runQuiet {
				fmt.Printf("%s %s\n",
					utils.Styled("Using last generated command:", utils.StyleInfo),
					utils.Styled(command, utils.StyleCommand))
			}
		} else {
			// Command provided as argument
			command = args[0]
		}

		if runQuiet {
			// In quiet mode, suppress some output
			oldVerbose := verbose
			verbose = false
			defer func() { verbose = oldVerbose }()
		}

		if runForce {
			// Force execution - set the global forceRun flag temporarily
			oldForceRun := forceRun
			forceRun = true
			defer func() { forceRun = oldForceRun }()
		}

		if verbose && !runQuiet {
			fmt.Printf("üîç Executing command: %s\n", command)
		}

		// Use enhanced danger assessment
		return executeCommandEnhanced(command)
	},
}

// executeCommandEnhanced runs a command with sophisticated danger assessment
func executeCommandEnhanced(command string) error {
	if command == "" {
		return fmt.Errorf("no command to execute")
	}

	// Create danger detector and assess the command
	detector := security.NewDangerDetector()
	ctx := &llm.Context{
		OS:               utils.GetOperatingSystem(),
		Shell:            utils.GetCurrentShell(),
		WorkingDirectory: utils.GetWorkingDirectory(),
	}
	assessment := detector.AssessCommand(command, ctx)

	// Show danger assessment
	if assessment.Level != llm.DangerLevelSafe {
		dangerIcon := utils.DangerIcon(string(assessment.Level))
		fmt.Printf("\n%s\n", utils.Divider("SECURITY ASSESSMENT", utils.StyleWarning))
		fmt.Printf("%s %s\n", dangerIcon,
			utils.Styled(strings.ToUpper(string(assessment.Level))+" DANGER LEVEL", utils.StyleWarning))
		fmt.Printf("%s %s\n", utils.Styled("Reason:", utils.StyleSubtle), assessment.Reason)

		if len(assessment.Factors) > 0 {
			fmt.Printf("\n%s\n", utils.Styled("Risk Factors:", utils.StyleWarning))
			factorList := utils.List(assessment.Factors, utils.StyleWarning)
			fmt.Printf("%s\n", factorList)
		}

		if len(assessment.Mitigations) > 0 {
			fmt.Printf("\n%s\n", utils.Styled("Safety Recommendations:", utils.StyleInfo))
			mitigationList := utils.List(assessment.Mitigations, utils.StyleInfo)
			fmt.Printf("%s\n", mitigationList)
		}
		fmt.Println()
	}

	// Enhanced safety checks based on danger level
	if assessment.Level.IsAtLeastLevel(llm.DangerLevelMedium) && !runForce {
		if err := handleDangerousExecution(command, assessment); err != nil {
			if errors.Is(err, ErrCommandCancelled) {
				return nil // User cancelled, not an error
			}
			return err
		}
	} else if !runForce {
		// For low/safe commands, still ask for confirmation unless forced
		if !runQuiet {
			fmt.Printf("\n%s\n", utils.Divider("CONFIRMATION", utils.StyleInfo))
			fmt.Printf("%s %s\n", utils.Styled("Execute:", utils.StyleCommand), command)
			fmt.Printf("%s ", utils.Styled("Continue? [Y/n]:", utils.StyleInfo))

			reader := bufio.NewReader(os.Stdin)
			response, err := reader.ReadString('\n')
			if err != nil {
				return fmt.Errorf("failed to read confirmation: %w", err)
			}

			response = strings.TrimSpace(strings.ToLower(response))
			if response != "" && response != "y" && response != "yes" {
				fmt.Printf("%s Command execution cancelled\n", utils.Styled("[CANCELLED]", utils.StyleError))
				return nil
			}
		}
	}

	// Show warnings again before execution
	if len(assessment.Factors) > 0 && !runQuiet {
		fmt.Printf("\n%s\n", utils.Styled("Final Warnings:", utils.StyleWarning))
		factorList := utils.List(assessment.Factors, utils.StyleWarning)
		fmt.Printf("%s\n", factorList)
	}

	// Execute the command directly
	if !runQuiet {
		fmt.Printf("\n%s\n", utils.Divider("EXECUTION", utils.StyleCommand))
		fmt.Printf("%s %s\n", utils.Styled("Executing:", utils.StyleCommand), command)
		fmt.Printf("%s\n", utils.Divider("", utils.StyleSubtle))
	}

	cmd := exec.Command(utils.GetCurrentShell(), "-c", command)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	err := cmd.Run()

	if !runQuiet {
		fmt.Printf("%s\n", utils.Divider("", utils.StyleSubtle))
	}

	if err != nil {
		fmt.Printf("%s Command failed: %v\n", utils.Styled("[ERROR]", utils.StyleError), err)
		return err
	}

	if !runQuiet {
		fmt.Printf("%s Command completed successfully\n", utils.Styled("[SUCCESS]", utils.StyleSuccess))
	}

	return nil
}

// handleDangerousExecution handles execution confirmation for dangerous commands
func handleDangerousExecution(command string, assessment llm.DangerAssessment) error {
	dangerIcon := utils.DangerIcon(string(assessment.Level))

	fmt.Printf("\n%s\n", utils.Box("DANGEROUS COMMAND DETECTED", "", utils.StyleDanger))
	fmt.Printf("%s %s\n", dangerIcon,
		utils.Styled(strings.ToUpper(string(assessment.Level))+" COMMAND DETECTED!", utils.StyleDanger))
	fmt.Printf("%s %s\n", utils.Styled("Command:", utils.StyleCommand), command)
	fmt.Printf("%s %s\n\n", utils.Styled("Reason:", utils.StyleSubtle), assessment.Reason)

	if assessment.Level.IsAtLeastLevel(llm.DangerLevelHigh) {
		fmt.Printf("%s ", utils.Styled("This command may be destructive. Type 'YES I UNDERSTAND THE RISKS' to confirm:", utils.StyleDanger))

		reader := bufio.NewReader(os.Stdin)
		response, err := reader.ReadString('\n')
		if err != nil {
			return fmt.Errorf("failed to read confirmation: %w", err)
		}

		if strings.TrimSpace(response) != "YES I UNDERSTAND THE RISKS" {
			fmt.Printf("%s Command execution cancelled\n", utils.Styled("[CANCELLED]", utils.StyleError))
			return ErrCommandCancelled
		}
	} else {
		fmt.Printf("%s ", utils.Styled("Continue? (type 'yes' to confirm):", utils.StyleWarning))

		reader := bufio.NewReader(os.Stdin)
		response, err := reader.ReadString('\n')
		if err != nil {
			return fmt.Errorf("failed to read confirmation: %w", err)
		}

		if strings.TrimSpace(strings.ToLower(response)) != "yes" {
			fmt.Printf("%s Command execution cancelled\n", utils.Styled("[CANCELLED]", utils.StyleError))
			return ErrCommandCancelled
		}
	}

	return nil
}

// getDangerIcon returns an appropriate icon for the danger level
func getDangerIcon(level llm.DangerLevel) string {
	switch level {
	case llm.DangerLevelSafe:
		return "‚úÖ"
	case llm.DangerLevelLow:
		return "üü°"
	case llm.DangerLevelMedium:
		return "üü†"
	case llm.DangerLevelHigh:
		return "üî¥"
	case llm.DangerLevelCritical:
		return "üíÄ"
	default:
		return "‚ùì"
	}
}

func init() {
	rootCmd.AddCommand(runCmd)

	// Add flags for the run command
	runCmd.Flags().BoolVarP(&runForce, "force", "F", false, "force execute without confirmation (DANGEROUS)")
	runCmd.Flags().BoolVarP(&runQuiet, "quiet", "q", false, "quiet mode - less output")
}
